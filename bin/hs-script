#!/bin/sh

RESOLVER=lts-12.9

set -ue

err()
{
	fmt="$1"
	shift
	printf "$fmt\n" "$@" 1>&2
	exit 1
}

is_executable_on_path()
{
	which "$@" > /dev/null
}

any_executable()
{
	for x in $@; do
		which $x && return 0
	done

	return 1
}

stack_install_cmd()
{
	name=$1
	echo "stack install --resolver $RESOLVER --install-ghc $name"
}

system_install_cmd_()
{
	param=$1
	shift

	for pkgman in "$@"; do
		if is_executable_on_path $pkgman; then
			echo "sudo $pkgman $param"
			return 0
		fi
	done

	return 1
}

system_install_cmd="` system_install_cmd_ install apt apt-get yum \
                   || system_install_cmd_ add apk \
                   || system_install_cmd_ -i nix-env \
                   || echo "use your package manager to install" \
	           `"

dep()
{
	name=$1
	hint="$2"
	is_executable_on_path $name || err "Missing dependency: $name, $hint"
}

dep awk "$system_install_cmd awk"
dep grep "$system_install_cmd grep"
dep sed "$system_install_cmd sed"
dep stack "$system_install_cmd stack"

if [ $# -lt 2 ]; then
	cat <<EOF 1>&2
Usage: script_name command [cmd params]
Commands:
	new
	repl
	watch
	lint
	fix-linting
	compile
	profile [additional RTS options]
EOF
	exit 1
fi

script_path="$1"
script_dir="`dirname "$script_path"`"
script_name="`basename "$script_path"`"
cmd=$2

shift 2

if [ ! -d "$script_dir" ]; then
	mkdir -p "$script_dir"
fi

cd "$script_dir"

new()
{
	cat <<EOF > "$script_path"
#!/usr/bin/env stack
{- stack --resolver $RESOLVER --install-ghc runghc
   --package containers
   --package regex-compat
   --package process
   --package directory
-}

{- COMPILE_FLAGS -O2 -threaded -rtsopts "" -eventlog -}

-- https://downloads.haskell.org/~ghc/8.2.2/docs/html/users_guide/using-warnings.html
{-# OPTIONS_GHC -Werror -Wall -Wcompat                                  #-}
{-# OPTIONS_GHC -Wincomplete-uni-patterns -Wincomplete-record-updates   #-}
{-# OPTIONS_GHC -Widentities -Wredundant-constraints                    #-}
{-# OPTIONS_GHC -Wmonomorphism-restriction -Wmissing-home-modules       #-}

{-# OPTIONS_GHC -fno-warn-unused-imports -fno-warn-unused-matches       #-}
{-# OPTIONS_GHC -fno-warn-unused-top-binds -fno-warn-unused-local-binds #-}
-- {-# OPTIONS_GHC -ddump-minimal-imports                               #-}

import             Data.Semigroup
import             Data.Foldable
import             Data.Traversable
import             System.Directory
import             System.Environment
import             System.Exit
import             System.IO
import             System.Process
import             Text.Regex

main :: IO ()
main = do
    putStrLn "stdin:"
    getContents >>= putStrLn

    args <- getArgs
    putStrLn "args:"
    traverse_ (hPutStrLn stderr) args 

    exitFailure
EOF

	chmod 755 "$script_path"
}

replaced_cmd()
{
	replacement=$1

	awk -vreplacement=$replacement '
		BEGIN { x = 0; cmd = "" }

		x == 1 {
			cmd = cmd " " $0
		}

		/^{- stack/ {
			x = 1;
			sub(/^{- /, "");
			sub(/runghc/, replacement)
			cmd = $0
		}

		/-}/ { x = 0 }

		END { 
			sub(/-}/, "", cmd)
			sub(/ {2,}/, " ", cmd)
			print cmd
		}
	' < "$script_path"
}

ghci_cmd()
{
	echo `replaced_cmd ghci` --ghci-options '-DGHCI=1' "$script_name"
}

repl()
{
	`ghci_cmd`
}

highlight()
{
	if is_executable_on_path source-highlight; then
		source-highlight -s haskell -f esc
	else
		echo "Hint: Install source-highlight to nicer output; $system_install_cmd source-highlight"
		cat
	fi
}

watch()
{
	dep ghcid "`stack_install_cmd ghcid`"
	ctags_cmd=":ctags"
	found=`any_executable fast-tags hasktags || echo`
	if [ ! -z "$found" ]; then
		echo "INFO: $found on path - not using ghci :ctags in case of overwrite"
		ctags_cmd=""
	fi

	ghcid -h8 -T "$ctags_cmd" -c "`ghci_cmd`" | highlight
}

lint()
{
	dep hlint "`stack_install_cmd hlint`"

	hlint "$script_path"
}

fix_linting()
{
	dep hlint "`stack_install_cmd hlint`"
	dep refactor "`stack_install_cmd apply-refact`"

	hlint --refactor --refactor-options="-is" "$script_path"
}

compile_flags()
{
	awk '/^{- COMPILE_FLAGS / { sub(/^{- COMPILE_FLAGS /, ""); sub(/ -}/, ""); print; exit 0 }' < "$script_path"
}

compile()
{
	`replaced_cmd ghc` -- `compile_flags` "$script_name"
}

case $cmd in
"new")
	new
	;;

"repl")
	repl
	;;

"watch")
	watch
	;;
"lint")
	lint
	;;
"fix-linting")
	fix_linting
	;;

"compile")
	compile
	;;

"profile")
	is_executable_on_path threadscope || echo "Hint: install threadscope to aid in profiling/optimization: $system_install_cmd threadscope"
	compile

	# TODO: use `compile_opts` to get -rtsopts and use that here, overriding with passed in params if neccessary
	rts_args="+RTS -s"
	if ! echo "$@" | grep -q -- '-N[0-9]\+\b'; then
		echo "INFO: as -N<cores> was not provided, -N is being used which uses all cores"
		rts_args="$rts_args -N"
	fi

	echo "INFO: using RTS args; $rts_args $@"

	./"`echo "$script_name" | sed 's/\.hs$//'`" $rts_args "$@"
	;;
*)
	err "Unknown command $cmd"
esac
